package com.megacreative.coding.debug;

import com.megacreative.MegaCreative;
import com.megacreative.coding.CodeBlock;
import com.megacreative.coding.values.DataValue;
import com.megacreative.coding.variables.VariableScope;
import org.bukkit.Location;
import org.bukkit.entity.Player;

import java.util.*;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Logger;

public class VisualDebugger {
    private static final Logger log = Logger.getLogger(VisualDebugger.class.getName());
    
    private final MegaCreative plugin;
    private final Map<UUID, DebugSession> activeSessions = new ConcurrentHashMap<>();
    private final Map<UUID, BreakpointManager> breakpointManagers = new ConcurrentHashMap<>();
    private final Map<UUID, ExecutionTracer> executionTracers = new ConcurrentHashMap<>();
    private final Map<UUID, VariableWatcher> variableWatchers = new ConcurrentHashMap<>();
    private final AdvancedVisualDebugger advancedDebugger;

    public VisualDebugger(MegaCreative plugin) {
        this.plugin = plugin;
        this.advancedDebugger = new AdvancedVisualDebugger(plugin, this);
        
        plugin.getServer().getScheduler().runTaskTimer(plugin, () -> {
            for (Player player : plugin.getServer().getOnlinePlayers()) {
                breakpointManagers.computeIfAbsent(player.getUniqueId(), k -> new BreakpointManager());
                executionTracers.computeIfAbsent(player.getUniqueId(), k -> new ExecutionTracer());
                variableWatchers.computeIfAbsent(player.getUniqueId(), k -> new VariableWatcher());
            }
        }, 20L, 6000L);
    }

    // [Previous methods remain the same...]

    private static class DebugSession {
        final String sessionName;
        final Player player;
        int executionStep = 0;
        int errorCount = 0;
        
        DebugSession(Player player, String sessionName) {
            this.player = player;
            this.sessionName = sessionName;
        }
    }

    public static class Breakpoint {
        private final Location location;
        private final String condition;
        private final long createdTime;
        
        public Breakpoint(Location location, String condition) {
            this.location = location.clone();
            this.condition = condition;
            this.createdTime = System.currentTimeMillis();
        }
        
        public Location getLocation() { return location; }
        public String getCondition() { return condition; }
        public long getCreatedTime() { return createdTime; }
    }

    public static class BreakpointManager {
        private final Map<String, Breakpoint> breakpoints = new ConcurrentHashMap<>();
        
        public void addBreakpoint(Breakpoint breakpoint) {
            String key = formatLocationKey(breakpoint.getLocation());
            breakpoints.put(key, breakpoint);
        }
        
        public boolean removeBreakpoint(Location location) {
            String key = formatLocationKey(location);
            return breakpoints.remove(key) != null;
        }
        
        public boolean hasBreakpointAt(Location location) {
            String key = formatLocationKey(location);
            return breakpoints.containsKey(key);
        }
        
        public Breakpoint getBreakpointAt(Location location) {
            String key = formatLocationKey(location);
            return breakpoints.get(key);
        }
        
        public List<Breakpoint> getBreakpoints() {
            return new ArrayList<>(breakpoints.values());
        }
        
        private String formatLocationKey(Location location) {
            if (location == null) return "";
            return String.format("%d,%d,%d,%s", 
                location.getBlockX(), 
                location.getBlockY(), 
                location.getBlockZ(),
                location.getWorld() != null ? location.getWorld().getName() : "");
        }
    }

    public static class ExecutionStep {
        private final String action;
        private final Location location;
        private final long timestamp;
        
        public ExecutionStep(String action, Location location, long timestamp) {
            this.action = action;
            this.location = location.clone();
            this.timestamp = timestamp;
        }
        
        public String getAction() { return action; }
        public Location getLocation() { return location; }
        public long getTimestamp() { return timestamp; }
    }

    public static class ExecutionTracer {
        private final List<ExecutionStep> trace = new ArrayList<>();
        private final int maxSteps;
        private int tracedSteps = 0;
        
        public ExecutionTracer() {
            this(1000);
        }
        
        public ExecutionTracer(int maxSteps) {
            this.maxSteps = maxSteps > 0 ? maxSteps : 1000;
        }
        
        public void addStep(ExecutionStep step) {
            tracedSteps++;
            if (trace.size() >= maxSteps) {
                trace.remove(0);
            }
            trace.add(step);
        }
        
        public List<ExecutionStep> getTrace() { return new ArrayList<>(trace); }
        public int getTracedSteps() { return tracedSteps; }
        public int getMaxSteps() { return maxSteps; }
    }

    public static class VariableWatcher {
        private final Map<String, String> watches = new ConcurrentHashMap<>();
        
        public void addWatch(String variableName, String expression) {
            watches.put(variableName, expression);
        }
        
        public boolean removeWatch(String variableName) {
            return watches.remove(variableName) != null;
        }
        
        public Map<String, String> getWatches() {
            return new HashMap<>(watches);
        }
        
        public boolean hasWatches() {
            return !watches.isEmpty();
        }
    }
}

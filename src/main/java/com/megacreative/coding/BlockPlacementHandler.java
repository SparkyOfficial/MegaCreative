package com.megacreative.coding;

import com.megacreative.MegaCreative;
import com.megacreative.core.ServiceRegistry;
import com.megacreative.interfaces.ITrustedPlayerManager;
import com.megacreative.services.BlockConfigService;
import com.megacreative.gui.coding.ActionParameterGUI;
import com.megacreative.gui.coding.ActionSelectionGUI;
import com.megacreative.coding.values.DataValue; // üîß FIX: Add correct import
import com.megacreative.coding.values.types.AnyValue; // üîß FIX: Add correct import
import com.megacreative.coding.values.types.TextValue; // üîß FIX: Add correct import
import com.megacreative.coding.values.types.NumberValue; // üîß FIX: Add correct import
import com.megacreative.coding.values.types.BooleanValue; // üîß FIX: Add correct import
import com.megacreative.coding.values.types.ListValue; // üîß FIX: Add correct import
import org.bukkit.Material;
import java.util.logging.Logger;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.block.Sign;
import org.bukkit.block.data.type.WallSign;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.Location;
import org.bukkit.World;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.List; // üîß FIX: Add missing import

/**
 * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å –±–ª–æ–∫–∞–º–∏ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è
 */
public class BlockPlacementHandler implements Listener {
    private static final Logger log = Logger.getLogger(BlockPlacementHandler.class.getName());
    
    private final MegaCreative plugin;
    private final ITrustedPlayerManager trustedPlayerManager;
    private final BlockConfigService blockConfigService;
    private final Map<Location, CodeBlock> blockCodeBlocks = new HashMap<>();
    private final Map<UUID, Boolean> playerVisualizationStates = new HashMap<>();
    private final Map<UUID, Boolean> playerDebugStates = new HashMap<>();
    private final Map<UUID, Location> playerSelections = new HashMap<>();
    private final Map<UUID, CodeBlock> clipboard = new HashMap<>(); // –ë—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è

    public BlockPlacementHandler(MegaCreative plugin) {
        this.plugin = plugin;
        ServiceRegistry registry = plugin.getServiceRegistry();
        this.trustedPlayerManager = registry.getTrustedPlayerManager();
        this.blockConfigService = registry.getBlockConfigService();
    }
    
    /**
     * –û—á–∏—â–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–≥—Ä–æ–∫–∞ –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏
     * @param playerId UUID –∏–≥—Ä–æ–∫–∞
     */
    public void cleanUpPlayerData(UUID playerId) {
        playerVisualizationStates.remove(playerId);
        playerDebugStates.remove(playerId);
        playerSelections.remove(playerId);
        clipboard.remove(playerId);
    }

    /**
     * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –±–ª–æ–∫–æ–≤ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è
     */
    @EventHandler(priority = EventPriority.HIGH) // Run before AutoConnectionManager (MONITOR)
    public void onBlockPlace(BlockPlaceEvent event) {
        if (event.isCancelled()) return; // Don't process if already cancelled by DevWorldProtectionListener
        
        Player player = event.getPlayer();
        Block block = event.getBlockPlaced();
        ItemStack itemInHand = event.getItemInHand();
        
        // Only process in dev worlds
        if (!isInDevWorld(player)) return;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –ø—Ä–µ–¥–º–µ—Ç –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è
        if (!itemInHand.hasItemMeta() || !itemInHand.getItemMeta().hasDisplayName()) {
            // –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –ø—Ä–µ–¥–º–µ—Ç, –≤–æ–∑–º–æ–∂–Ω–æ, —ç—Ç–æ –æ–±—ã—á–Ω—ã–π –±–ª–æ–∫ - –µ–≥–æ –Ω—É–∂–Ω–æ –∑–∞–ø—Ä–µ—Ç–∏—Ç—å
            if (!blockConfigService.isCodeBlock(block.getType())) {
                // –û—Å–æ–±–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –ø–æ—Ä—à–Ω–µ–π (—Å–∫–æ–±–æ–∫) - –æ–Ω–∏ –º–æ–≥—É—Ç –Ω–µ –∏–º–µ—Ç—å –∫–æ–Ω—Ñ–∏–≥–∞
                if (block.getType() == Material.PISTON || block.getType() == Material.STICKY_PISTON) {
                    CodeBlock newCodeBlock = new CodeBlock(block.getType(), "BRACKET"); // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –¥–ª—è —Å–∫–æ–±–æ–∫
                    newCodeBlock.setBracketType(CodeBlock.BracketType.OPEN); // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –æ—Ç–∫—Ä—ã–≤–∞—é—â–∞—è
                    setPistonDirection(block, CodeBlock.BracketType.OPEN); // –ó–∞–¥–∞—Ç—å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                    updateBracketSign(block.getLocation(), CodeBlock.BracketType.OPEN); // –ü–æ–≤–µ—Å–∏—Ç—å —Ç–∞–±–ª–∏—á–∫—É
                    blockCodeBlocks.put(block.getLocation(), newCodeBlock);
                    
                    player.sendMessage("¬ßa‚úì –°–∫–æ–±–∫–∞ —Ä–∞–∑–º–µ—â–µ–Ω–∞: " + CodeBlock.BracketType.OPEN.getDisplayName());
                    player.sendMessage("¬ß7–ö–ª–∏–∫–Ω–∏—Ç–µ –ø—Ä–∞–≤–æ–π –∫–Ω–æ–ø–∫–æ–π –¥–ª—è —Å–º–µ–Ω—ã —Ç–∏–ø–∞");
                    return; // –ó–∞–≤–µ—Ä—à–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É
                }
                return; // –≠—Ç–æ –æ–±—ã—á–Ω—ã–π –±–ª–æ–∫, –Ω–µ –∫–æ–¥–æ–≤—ã–π
            }
        }
        
        // –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥ –±–ª–æ–∫–∞ –∏–∑ –ø—Ä–µ–¥–º–µ—Ç–∞ –≤ —Ä—É–∫–µ
        String displayName = org.bukkit.ChatColor.stripColor(itemInHand.getItemMeta().getDisplayName());
        BlockConfigService.BlockConfig config = blockConfigService.getBlockConfigByDisplayName(displayName);
        
        if (config == null) {
            // –≠—Ç–æ –Ω–µ –∫–æ–¥–æ–≤—ã–π –±–ª–æ–∫, –∑–∞–ø—Ä–µ—â–∞–µ–º —É—Å—Ç–∞–Ω–æ–≤–∫—É
            // event.setCancelled(true); // –£–ë–ò–†–ê–ï–ú –û–¢–ú–ï–ù–£ –°–û–ë–´–¢–ò–Ø
            player.sendMessage("¬ßc–í—ã –º–æ–∂–µ—Ç–µ —Ä–∞–∑–º–µ—â–∞—Ç—å —Ç–æ–ª—å–∫–æ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –±–ª–æ–∫–∏ –¥–ª—è –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è!");
            return;
        }
        
        // ===============================================
        //           –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê –ö–û–ù–°–¢–†–£–ö–¢–û–†–û–í
        // ===============================================
        
        // 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –±–ª–æ–∫ "–∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–æ–º"
        if (config.isConstructor()) {
            // 2. –ù–ï –æ—Ç–º–µ–Ω—è–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –±–ª–æ–∫–∞, –ø–æ–∑–≤–æ–ª—è–µ–º –µ–º—É —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è
            // event.setCancelled(true); // –£–ë–ò–†–ê–ï–ú –û–¢–ú–ï–ù–£ –°–û–ë–´–¢–ò–Ø
            
            // 3. –†–∞–∑–º–µ—â–∞–µ–º –±–ª–æ–∫ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ (–±–µ–∑ –≤—ã–∑–æ–≤–∞ —Å–æ–±—ã—Ç–∏—è) - –ù–ï –ù–£–ñ–ù–û, –ü–û–ó–í–û–õ–Ø–ï–ú –°–û–ë–´–¢–ò–Æ –ó–ê–í–ï–†–®–ò–¢–¨–°–Ø
            
            // 4. –í—ã–∑—ã–≤–∞–µ–º –º–µ—Ç–æ–¥ –¥–ª—è –ø–æ—Å—Ç—Ä–æ–π–∫–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π —Ç–∏–∫
            // –ó–∞–ø–ª–∞–Ω–∏—Ä—É–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π —Ç–∏–∫, —á—Ç–æ–±—ã —Å–æ–±—ã—Ç–∏–µ BlockPlaceEvent –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–≤–µ—Ä—à–∏–ª–æ—Å—å
            org.bukkit.Bukkit.getScheduler().runTask(plugin, () -> {
                buildStructureFor(event, config);
                
                // 5. –í–∏–∑—É–∞–ª—å–Ω–∞—è –∏ –∞—É–¥–∏–æ –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å
                player.spawnParticle(org.bukkit.Particle.VILLAGER_HAPPY, block.getLocation().add(0.5, 1.0, 0.5), 5, 0.2, 0.2, 0.2, 0.1);
                player.playSound(block.getLocation(), org.bukkit.Sound.BLOCK_NOTE_BLOCK_PLING, 0.8f, 1.5f);
                
                player.sendMessage("¬ßa‚úì –°—Ç—Ä—É–∫—Ç—É—Ä–∞ " + config.getDisplayName() + " —Å–æ–∑–¥–∞–Ω–∞!");
                player.sendMessage("¬ß7–ö–ª–∏–∫–Ω–∏—Ç–µ –ø–æ —Ç–∞–±–ª–∏—á–∫–µ –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤");
            });
            
            return; // –ó–∞–≤–µ—Ä—à–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É, —á—Ç–æ–±—ã –Ω–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å –±–ª–æ–∫ –¥–≤–∞–∂–¥—ã
        }
        
        // –î–ª—è –æ–±—ã—á–Ω—ã—Ö –±–ª–æ–∫–æ–≤ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –ª–æ–≥–∏–∫—É
        // –°–æ–∑–¥–∞–µ–º CodeBlock —Å ID –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞
        String actionId = config.getId();
        
        // üîß FIX: Use default action if available for immediate functionality
        if (config.getDefaultAction() != null) {
            actionId = config.getDefaultAction();
        }
        
        CodeBlock newCodeBlock = new CodeBlock(block.getType(), actionId);
        
        // Special handling for bracket blocks (pistons)
        if (block.getType() == Material.PISTON || block.getType() == Material.STICKY_PISTON) {
            newCodeBlock.setBracketType(CodeBlock.BracketType.OPEN); // Default to opening bracket
            setPistonDirection(block, CodeBlock.BracketType.OPEN);
        }
        
        blockCodeBlocks.put(block.getLocation(), newCodeBlock);
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–±–ª–∏—á–∫—É —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞ (–¥–ª—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–æ–≤ —Ç–∞–±–ª–∏—á–∫–∞ —É–∂–µ —Å–æ–∑–¥–∞–Ω–∞ –≤ buildStructureFor)
        if (!config.isConstructor()) {
            setSignOnBlock(block.getLocation(), config.getDisplayName());
        }
        
        // –í–∏–∑—É–∞–ª—å–Ω–∞—è –∏ –∞—É–¥–∏–æ –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å
        player.spawnParticle(org.bukkit.Particle.VILLAGER_HAPPY, block.getLocation().add(0.5, 1.0, 0.5), 5, 0.2, 0.2, 0.2, 0.1);
        player.playSound(block.getLocation(), org.bukkit.Sound.BLOCK_NOTE_BLOCK_PLING, 0.8f, 1.5f);
        
        if (config.isConstructor()) {
            player.sendMessage("¬ßa‚úì –°—Ç—Ä—É–∫—Ç—É—Ä–∞ " + config.getDisplayName() + " —Å–æ–∑–¥–∞–Ω–∞!");
            player.sendMessage("¬ß7–ö–ª–∏–∫–Ω–∏—Ç–µ –ø–æ –æ—Å–Ω–æ–≤–Ω–æ–º—É –±–ª–æ–∫—É –¥–ª—è –≤—ã–±–æ—Ä–∞ –¥–µ–π—Å—Ç–≤–∏—è");
        } else {
            player.sendMessage("¬ßa‚úì –ë–ª–æ–∫ –∫–æ–¥–∞ —Ä–∞–∑–º–µ—â–µ–Ω: " + config.getDisplayName());
            player.sendMessage("¬ß7–ö–ª–∏–∫–Ω–∏—Ç–µ –ø—Ä–∞–≤–æ–π –∫–Ω–æ–ø–∫–æ–π –¥–ª—è –≤—ã–±–æ—Ä–∞ –¥–µ–π—Å—Ç–≤–∏—è");
        }
    }
    
    /**
     * –°–æ–∑–¥–∞–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–ª—è –±–ª–æ–∫–æ–≤-–∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–æ–≤ (–∞–Ω–∞–ª–æ–≥ WOOD –∏–∑ FrameLand)
     */
    private void buildStructureFor(BlockPlaceEvent event, BlockConfigService.BlockConfig config) {
        Block placedBlock = event.getBlock();
        Location loc = placedBlock.getLocation();
        World world = loc.getWorld();
        Player player = event.getPlayer();
        
        BlockConfigService.StructureConfig structure = config.getStructure();
        if (structure == null) {
            plugin.getLogger().warning("Constructor block " + config.getId() + " has no structure configuration!");
            return;
        }
        
        // üéÜ ENHANCED: More intuitive structure creation like FrameLand
        if (config.getType().equals("CONDITION") || config.getType().equals("CONTROL")) {
            int bracketDistance = structure.getBracketDistance();
            
            // Calculate optimal positioning based on surrounding blocks
            BlockFace buildDirection = findOptimalBuildDirection(loc, bracketDistance);
            
            // Create opening bracket (piston pointing inward)
            Location openBracketLoc = loc.clone().add(buildDirection.getModX(), 0, buildDirection.getModZ());
            
            // Create closing bracket (piston pointing outward)
            // üîß FIX: Correct bracket positioning - count from main block, not from open bracket
            Location closeBracketLoc = loc.clone().add(
                buildDirection.getModX() * (bracketDistance + 1), 
                0, 
                buildDirection.getModZ() * (bracketDistance + 1)
            );
            
            // 1. Create bracket pistons with proper orientation
            createBracketPiston(openBracketLoc, CodeBlock.BracketType.OPEN, player, buildDirection);
            createBracketPiston(closeBracketLoc, CodeBlock.BracketType.CLOSE, player, buildDirection.getOppositeFace());
            
            // 2. Create smart sign on main block that opens configuration GUI
            if (structure.hasSign()) {
                setSmartSignOnBlock(loc, config.getDisplayName(), config.getId());
            }
            
            // 3. Create container above main block for parameters (optional)
            if (config.getType().equals("CONDITION") && !config.getId().equals("else")) {
                spawnContainerAboveBlock(loc, config.getId());
            }
            
            // 4. Add visual effects for "magical" feeling
            addConstructionEffects(loc, player);
        }
        
        // Additional structure types can be added here
        // For example, EVENT blocks could spawn helper blocks
        else if (config.getType().equals("EVENT")) {
            // Event blocks get special treatment
            if (structure.hasSign()) {
                setSmartSignOnBlock(loc, config.getDisplayName() + " Event", config.getId());
            }
            
            // üîß FIX: Add "ore" block for event blocks to make them visible
            // Add diamond ore block to make the event block "magical"
            Location oreLoc = loc.clone().add(-1, 0, 0); // Place ore to the west of the event block
            if (oreLoc.getBlock().getType().isAir()) {
                oreLoc.getBlock().setType(Material.DIAMOND_ORE);
            }
            
            addConstructionEffects(loc, player);
        }
    }
    
    /**
     * üéÜ ENHANCED: Creates bracket piston with proper orientation
     */
    private void createBracketPiston(Location location, CodeBlock.BracketType bracketType, Player player, BlockFace facing) {
        Block pistonBlock = location.getWorld().getBlockAt(location);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –º–µ—Å—Ç–æ —Å–≤–æ–±–æ–¥–Ω–æ
        if (!pistonBlock.getType().isAir()) {
            return;
        }
        
        // –°—Ç–∞–≤–∏–º –ø–æ—Ä—à–µ–Ω—å
        pistonBlock.setType(Material.PISTON);
        
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π BlockData –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        org.bukkit.block.data.type.Piston pistonData = (org.bukkit.block.data.type.Piston) pistonBlock.getBlockData();
        
        // üéÜ ENHANCED: Smart piston orientation for FrameLand-style brackets
        if (bracketType == CodeBlock.BracketType.OPEN) {
            pistonData.setFacing(facing); // Points inward toward the structure
        } else {
            pistonData.setFacing(facing.getOppositeFace()); // Points outward from the structure
        }
        
        pistonBlock.setBlockData(pistonData);
        
        // –°–æ–∑–¥–∞–µ–º CodeBlock –¥–ª—è —Å–∫–æ–±–∫–∏
        CodeBlock bracketCodeBlock = new CodeBlock(Material.PISTON, "BRACKET");
        bracketCodeBlock.setBracketType(bracketType);
        blockCodeBlocks.put(location, bracketCodeBlock);
        
        // –î–æ–±–∞–≤–ª—è–µ–º —Ç–∞–±–ª–∏—á–∫—É –∫ —Å–∫–æ–±–∫–µ
        updateBracketSign(location, bracketType);
        
        // Add visual effects for FrameLand-style magic
        player.spawnParticle(org.bukkit.Particle.ENCHANTMENT_TABLE, location.add(0.5, 0.5, 0.5), 10, 0.3, 0.3, 0.3, 1);
        player.playSound(location, org.bukkit.Sound.BLOCK_ENCHANTMENT_TABLE_USE, 1.0f, 1.5f);
        
    }

    /**
     * –°–æ–∑–¥–∞–µ—Ç –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä (—Å—É–Ω–¥—É–∫) –Ω–∞–¥ –±–ª–æ–∫–æ–º –∫–æ–¥–∞ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
     */
    private void spawnContainerAboveBlock(Location blockLocation, String actionId) {
        Location containerLocation = blockLocation.clone().add(0, 1, 0);
        Block containerBlock = containerLocation.getBlock();
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –º–µ—Å—Ç–æ —Å–≤–æ–±–æ–¥–Ω–æ
        if (containerBlock.getType().isAir() || containerBlock.isLiquid()) {
            // –°–æ–∑–¥–∞–µ–º —Å—É–Ω–¥—É–∫
            containerBlock.setType(Material.CHEST);
            
            // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –Ω–∞—Å—Ç—Ä–æ–π–∫—É —Å—É–Ω–¥—É–∫–∞, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ

        }
    }

    /**
     * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ä–∞–∑—Ä—É—à–µ–Ω–∏–µ –±–ª–æ–∫–æ–≤ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è
     */
    @EventHandler(priority = EventPriority.HIGH) // Run before AutoConnectionManager
    public void onBlockBreak(BlockBreakEvent event) {
        if (event.isCancelled()) return;
        
        Location loc = event.getBlock().getLocation();
        Player player = event.getPlayer();
        
        // –£–¥–∞–ª—è–µ–º –±–ª–æ–∫ –∏–∑ –Ω–∞—à–µ–π –∫–∞—Ä—Ç—ã
        if (blockCodeBlocks.containsKey(loc)) {
            CodeBlock removedBlock = blockCodeBlocks.remove(loc);
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ –±–ª–æ–∫–æ–º-–∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–æ–º
            String blockId = removedBlock != null ? removedBlock.getAction() : null;
            if (blockId != null) {
                BlockConfigService.BlockConfig config = blockConfigService.getBlockConfig(blockId);
                if (config != null && config.isConstructor()) {
                    // –≠—Ç–æ –±–ª–æ–∫-–∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä, —É–¥–∞–ª—è–µ–º –≤—Å—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É
                    removeConstructorStructure(loc, config, player);
                }
                // ===============================================
                //           –î–û–†–ê–ë–û–¢–ö–ê –†–ê–ó–†–£–®–ï–ù–ò–Ø –°–¢–†–£–ö–¢–£–†
                // ===============================================
                // –ï—Å–ª–∏ —ç—Ç–æ —Å–æ–±—ã—Ç–∏–µ, —É–¥–∞–ª—è–µ–º "—Ä—É–¥—É"
                else if (config != null && "EVENT".equals(config.getType())) {
                    Block oreBlock = loc.clone().add(-1, 0, 0).getBlock();
                    if (oreBlock.getType() == Material.DIAMOND_ORE) { // –∏–ª–∏ –¥—Ä—É–≥–æ–π —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–π —Ä—É–¥—ã
                        oreBlock.setType(Material.AIR);
                    }
                }
            }
            
            // –£–¥–∞–ª—è–µ–º —Ç–∞–±–ª–∏—á–∫—É, –µ—Å–ª–∏ –æ–Ω–∞ –µ—Å—Ç—å
            removeSignFromBlock(loc);
            
            // –£–¥–∞–ª—è–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –Ω–∞–¥ –±–ª–æ–∫–æ–º, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
            removeContainerAboveBlock(loc);
            
            // AutoConnectionManager will handle disconnection automatically at MONITOR priority
            player.sendMessage("¬ßc–ë–ª–æ–∫ –∫–æ–¥–∞ —É–¥–∞–ª–µ–Ω!");
            
            plugin.getLogger().info("CodeBlock removed from " + loc + " with action: " + (removedBlock != null ? removedBlock.getAction() : "unknown"));
        }
    }
    
    /**
     * –£–¥–∞–ª—è–µ—Ç –≤—Å—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞ (—Å–∫–æ–±–∫–∏, –±–ª–æ–∫–∏ –≤–Ω—É—Ç—Ä–∏)
     */
    private void removeConstructorStructure(Location mainBlockLoc, BlockConfigService.BlockConfig config, Player player) {
        BlockConfigService.StructureConfig structure = config.getStructure();
        if (structure == null) return;
        
        if (config.getType().equals("CONDITION") || config.getType().equals("CONTROL")) {
            int bracketDistance = structure.getBracketDistance();
            
            // Calculate optimal positioning based on surrounding blocks (same as creation)
            BlockFace buildDirection = findOptimalBuildDirection(mainBlockLoc, bracketDistance);
            
            // –ú–µ—Å—Ç–∞ —Å–∫–æ–±–æ–∫
            Location openBracketLoc = mainBlockLoc.clone().add(buildDirection.getModX(), 0, buildDirection.getModZ());
            // üîß FIX: Correct bracket positioning - count from main block, not from open bracket
            Location closeBracketLoc = mainBlockLoc.clone().add(
                buildDirection.getModX() * (bracketDistance + 1), 
                0, 
                buildDirection.getModZ() * (bracketDistance + 1)
            );
            
            // –£–¥–∞–ª—è–µ–º —Å–∫–æ–±–∫–∏-–ø–æ—Ä—à–Ω–∏
            removeBracketPiston(openBracketLoc, player);
            removeBracketPiston(closeBracketLoc, player);
            
            // –£–¥–∞–ª—è–µ–º –≤—Å–µ –±–ª–æ–∫–∏ –º–µ–∂–¥—É —Å–∫–æ–±–∫–∞–º–∏ (–ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –º—É—Å–æ—Ä)
            for (int i = 1; i < bracketDistance; i++) {
                Location innerBlockLoc = mainBlockLoc.clone().add(
                    buildDirection.getModX() * i, 
                    0, 
                    buildDirection.getModZ() * i
                );
                if (blockCodeBlocks.containsKey(innerBlockLoc)) {
                    blockCodeBlocks.remove(innerBlockLoc);
                    removeSignFromBlock(innerBlockLoc);
                    removeContainerAboveBlock(innerBlockLoc);
                }
            }
            
            player.sendMessage("¬ße–°—Ç—Ä—É–∫—Ç—É—Ä–∞ " + config.getDisplayName() + " –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª–µ–Ω–∞!");
        }
    }
    
    /**
     * –£–¥–∞–ª—è–µ—Ç –ø–æ—Ä—à–µ–Ω—å-—Å–∫–æ–±–∫—É
     */
    private void removeBracketPiston(Location location, Player player) {
        if (blockCodeBlocks.containsKey(location)) {
            blockCodeBlocks.remove(location);
            removeSignFromBlock(location);
            
            Block pistonBlock = location.getBlock();
            if (pistonBlock.getType() == Material.PISTON || pistonBlock.getType() == Material.STICKY_PISTON) {
                pistonBlock.setType(Material.AIR);
            }
            
            // plugin.getLogger().fine("Removed bracket piston at " + location); // –£–ë–ò–†–ê–ï–ú –°–ü–ê–ú
        }
    }

    /**
     * –£–¥–∞–ª—è–µ—Ç –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –Ω–∞–¥ –±–ª–æ–∫–æ–º –∫–æ–¥–∞ (—É–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
     */
    private void removeContainerAboveBlock(Location blockLocation) {
        Location containerLocation = blockLocation.clone().add(0, 1, 0);
        Block containerBlock = containerLocation.getBlock();
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ —Ç–∏–ø—ã –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤
        if (containerBlock.getType() == Material.CHEST || 
            containerBlock.getType() == Material.TRAPPED_CHEST ||
            containerBlock.getType() == Material.BARREL ||
            containerBlock.getType() == Material.SHULKER_BOX ||
            containerBlock.getType().name().contains("SHULKER_BOX")) {
            
            // –û—á–∏—â–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –ø–µ—Ä–µ–¥ —É–¥–∞–ª–µ–Ω–∏–µ–º
            if (containerBlock.getState() instanceof org.bukkit.inventory.InventoryHolder) {
                org.bukkit.inventory.InventoryHolder holder = (org.bukkit.inventory.InventoryHolder) containerBlock.getState();
                holder.getInventory().clear();
            }
            
            containerBlock.setType(Material.AIR);
            // plugin.getLogger().fine("Removed container above code block at " + blockLocation); // –£–ë–ò–†–ê–ï–ú –°–ü–ê–ú
        }
    }

    /**
     * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å –±–ª–æ–∫–∞–º–∏
     */
    @EventHandler(priority = EventPriority.NORMAL)
    public void onPlayerInteract(PlayerInteractEvent event) {
        // Fix double firing by only processing main hand
        if (event.getHand() != org.bukkit.inventory.EquipmentSlot.HAND) {
            return;
        }
        
        Player player = event.getPlayer();
        ItemStack itemInHand = player.getInventory().getItemInMainHand();
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∂–µ–ª–µ–∑–Ω—ã–π —Å–ª–∏—Ç–æ–∫ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
        if (itemInHand.getType() == Material.IRON_INGOT && itemInHand.hasItemMeta() &&
            itemInHand.getItemMeta().getDisplayName().contains(CodingItems.DATA_CREATOR_NAME)) {
            event.setCancelled(true);
            // –£–±–∏—Ä–∞–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π DataGUI
            return;
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä–µ–ª—É –ù–ï –¥–ª—è –∏–Ω–≤–µ—Ä—Å–∏–∏ —É—Å–ª–æ–≤–∏–π
        if (itemInHand.getType() == Material.ARROW && itemInHand.hasItemMeta() &&
            itemInHand.getItemMeta().getDisplayName().contains(CodingItems.ARROW_NOT_NAME)) {
            handleArrowNotInteraction(player, event.getClickedBlock());
            event.setCancelled(true);
            return;
        }
        
        // –û—Å—Ç–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è –∫–ª–∏–∫–æ–≤ –ø–æ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –±–ª–æ–∫–∞–º
        if (event.getAction() != org.bukkit.event.block.Action.RIGHT_CLICK_BLOCK) return;
        
        Block clickedBlock = event.getClickedBlock();
        if (clickedBlock == null) return;
        
        Location location = clickedBlock.getLocation();
        
        // üéÜ ENHANCED: Check if player clicked on a smart sign
        if (clickedBlock.getType().name().contains("SIGN")) {
            if (handleSmartSignClick(clickedBlock, player)) {
                event.setCancelled(true);
                return;
            }
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ –±–ª–æ–∫ –∫–æ–¥–∞ –Ω–∞ —ç—Ç–æ–π –ª–æ–∫–∞—Ü–∏–∏
        if (blockCodeBlocks.containsKey(location)) {
            // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –æ—Ç–∫—Ä—ã—Ç–∏–µ GUI, –µ—Å–ª–∏ –≤ —Ä—É–∫–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç
            if (isTool(itemInHand)) {
                return;
            }
            
            event.setCancelled(true); // –í–∞–∂–Ω–æ, —á—Ç–æ–±—ã –Ω–µ –æ—Ç–∫—Ä—ã–ª—Å—è, –Ω–∞–ø—Ä–∏–º–µ—Ä, –≤–µ—Ä—Å—Ç–∞–∫
            
            // –û—Ç–∫—Ä—ã–≤–∞–µ–º GUI –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –±–ª–æ–∫–∞ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π —É–ª—É—á—à–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
            CodeBlock codeBlock = blockCodeBlocks.get(location);
            
            // Special handling for bracket blocks - toggle bracket type instead of opening GUI
            if (codeBlock.isBracket()) {
                toggleBracketType(codeBlock, event.getClickedBlock(), player);
                return;
            }
            
            // Handle block interaction with proper GUI opening
            handleBlockInteraction(player, location);
            return;
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∫–ª–∏–∫–Ω—É–ª –ª–∏ –∏–≥—Ä–æ–∫ –ø–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—É –Ω–∞–¥ –±–ª–æ–∫–æ–º –∫–æ–¥–∞
        Location blockBelow = location.clone().add(0, -1, 0);
        CodeBlock codeBlock = blockCodeBlocks.get(blockBelow);
        if (codeBlock != null) {
            event.setCancelled(true);
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø –±–ª–æ–∫–∞ - –æ—Ç–∫—Ä—ã–≤–∞–µ–º —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π GUI –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
            BlockConfigService.BlockConfig config = blockConfigService.getBlockConfig(codeBlock.getAction());
            if (config != null) {
                // –û—Ç–∫—Ä—ã–≤–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π drag-and-drop GUI –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è
                openParameterConfigGUI(player, blockBelow, codeBlock, config);
            } else {
                player.sendMessage("¬ßc–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è –¥–µ–π—Å—Ç–≤–∏—è " + codeBlock.getAction());
            }
        }
    }

    /**
     * –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ (–≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ "–º–∞–≥–∏–∏" FrameLand)
     * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å –±–ª–æ–∫–æ–º –∫–æ–¥–∞ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–≥–æ GUI
     */
    private void handleBlockInteraction(Player player, Location blockLocation) {
        CodeBlock codeBlock = blockCodeBlocks.get(blockLocation);
        if (codeBlock == null) return;
        
        // –ï—Å–ª–∏ —ç—Ç–æ –ø–æ—Ä—à–µ–Ω—å (—Å–∫–æ–±–∫–∞), –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Ç–∏–ø
        if (codeBlock.isBracket()) {
            toggleBracketType(codeBlock, blockLocation.getBlock(), player);
            return;
        }

        // –ï—Å–ª–∏ —É –±–ª–æ–∫–∞ –µ—â–µ –Ω–µ—Ç –¥–µ–π—Å—Ç–≤–∏—è, –æ—Ç–∫—Ä—ã–≤–∞–µ–º GUI –≤—ã–±–æ—Ä–∞ –¥–µ–π—Å—Ç–≤–∏—è
        if (codeBlock.getAction() == null || codeBlock.getAction().equals("NOT_SET") || blockConfigService.getBlockConfig(codeBlock.getAction()) == null) {
            // –í—ã–∑—ã–≤–∞–µ–º GUI –¥–ª—è –≤—ã–±–æ—Ä–∞ –¥–µ–π—Å—Ç–≤–∏—è, –∫–æ—Ç–æ—Ä–æ–µ —Ç—ã —É–∂–µ —Å–æ–∑–¥–∞–ª
            openActionSelectionGUI(player, blockLocation, codeBlock.getMaterial());
        } else {
            // –ò–Ω–∞—á–µ –æ—Ç–∫—Ä—ã–≤–∞–µ–º GUI –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
            BlockConfigService.BlockConfig config = blockConfigService.getBlockConfig(codeBlock.getAction());
            if (config != null) {
                // –í—ã–∑—ã–≤–∞–µ–º GUI –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, –∫–æ—Ç–æ—Ä–æ–µ —Ç—ã —É–∂–µ —Å–æ–∑–¥–∞–ª
                openParameterConfigGUI(player, blockLocation, codeBlock, config);
            } else {
                player.sendMessage("¬ßc–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è –¥–µ–π—Å—Ç–≤–∏—è '" + codeBlock.getAction() + "'");
            }
        }
    }
    
    /**
     * –û—Ç–∫—Ä—ã–≤–∞–µ—Ç GUI –¥–ª—è –≤—ã–±–æ—Ä–∞ –¥–µ–π—Å—Ç–≤–∏—è
     */
    private void openActionSelectionGUI(Player player, Location blockLocation, Material blockMaterial) {
        ActionSelectionGUI gui = new ActionSelectionGUI(plugin, player, blockLocation, blockMaterial);
        gui.open();
        
        BlockConfigService.BlockConfig config = blockConfigService.getBlockConfigByMaterial(blockMaterial);
        String blockName = config != null ? config.getDisplayName() : blockMaterial.name();
        player.sendMessage("¬ße–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –¥–ª—è –±–ª–æ–∫–∞: ¬ßf" + blockName);
    }

    /**
     * –û—Ç–∫—Ä—ã–≤–∞–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—ã–π drag-and-drop GUI –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –±–ª–æ–∫–∞
     */
    private void openParameterConfigGUI(Player player, Location blockLocation, CodeBlock codeBlock, BlockConfigService.BlockConfig config) {
        // –°–æ–∑–¥–∞–µ–º –∏ –æ—Ç–∫—Ä—ã–≤–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π GUI –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è
        ActionParameterGUI gui = new ActionParameterGUI(
            plugin, player, blockLocation, codeBlock.getAction());
        gui.open();
        
        player.sendMessage("¬ße–û—Ç–∫—Ä—ã—Ç–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è –¥–µ–π—Å—Ç–≤–∏—è: ¬ßf" + config.getDisplayName());
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –∏–≥—Ä–æ–∫ –≤ –º–∏—Ä–µ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
     */
    public boolean isInDevWorld(Player player) {  // Changed from private to public
        String worldName = player.getWorld().getName();
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –Ω–∞–∑–≤–∞–Ω–∏–π –º–∏—Ä–æ–≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
        return worldName.contains("dev") || worldName.contains("Dev") || 
               worldName.contains("—Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞") || worldName.contains("–†–∞–∑—Ä–∞–±–æ—Ç–∫–∞") ||
               worldName.contains("creative") || worldName.contains("Creative");
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø—Ä–µ–¥–º–µ—Ç –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–º
     */
    private boolean isTool(ItemStack item) {
        if (item == null) return false;
        
        Material type = item.getType();
        return type == Material.WOODEN_AXE || type == Material.STONE_AXE || 
               type == Material.IRON_AXE || type == Material.DIAMOND_AXE || 
               type == Material.NETHERITE_AXE || type == Material.WOODEN_PICKAXE || 
               type == Material.STONE_PICKAXE || type == Material.IRON_PICKAXE || 
               type == Material.DIAMOND_PICKAXE || type == Material.NETHERITE_PICKAXE ||
               type == Material.WOODEN_SHOVEL || type == Material.STONE_SHOVEL || 
               type == Material.IRON_SHOVEL || type == Material.DIAMOND_SHOVEL || 
               type == Material.NETHERITE_SHOVEL || type == Material.WOODEN_HOE || 
               type == Material.STONE_HOE || type == Material.IRON_HOE || 
               type == Material.DIAMOND_HOE || type == Material.NETHERITE_HOE;
    }

    /**
     * –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Ç–∞–±–ª–∏—á–∫–∏.
     */
    private void setSignOnBlock(Location location, String text) {
        removeSignFromBlock(location); // –°–Ω–∞—á–∞–ª–∞ —É–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ —Ç–∞–±–ª–∏—á–∫–∏

        Block block = location.getBlock();
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏
        BlockFace[] faces = {BlockFace.NORTH, BlockFace.EAST, BlockFace.SOUTH, BlockFace.WEST};
        
        for (BlockFace face : faces) {
            Block signBlock = block.getRelative(face);
            if (signBlock.getType().isAir()) {
                signBlock.setType(Material.OAK_WALL_SIGN, false); // false - –Ω–µ –≤—ã–∑—ã–≤–∞—Ç—å —Ñ–∏–∑–∏–∫—É
                
                WallSign wallSignData = (WallSign) signBlock.getBlockData();
                wallSignData.setFacing(face); // –¢–∞–±–ª–∏—á–∫–∞ —Å–º–æ—Ç—Ä–∏—Ç –ù–ê –±–ª–æ–∫
                signBlock.setBlockData(wallSignData);
                
                Sign signState = (Sign) signBlock.getState();
                signState.setLine(0, "¬ß8============");
                // –û–±—Ä–µ–∑–∞–µ–º —Ç–µ–∫—Å—Ç, –µ—Å–ª–∏ –æ–Ω —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π
                String line2 = text.length() > 15 ? text.substring(0, 15) : text;
                signState.setLine(1, line2);
                signState.setLine(2, "¬ß7–ö–ª–∏–∫–Ω–∏—Ç–µ –ü–ö–ú");
                signState.setLine(3, "¬ß8============");
                signState.update(true);
                
                return; // –í–ê–ñ–ù–û: –í—ã—Ö–æ–¥–∏–º –∏–∑ –º–µ—Ç–æ–¥–∞ –ø–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ü–ï–†–í–û–ô —Ç–∞–±–ª–∏—á–∫–∏
            }
        }
    }
    
    /**
     * –£–¥–∞–ª—è–µ—Ç –≤—Å–µ —Ç–∞–±–ª–∏—á–∫–∏ –≤–æ–∫—Ä—É–≥ –±–ª–æ–∫–∞ (—É–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
     */
    private void removeSignFromBlock(Location location) {
        Block block = location.getBlock();
        BlockFace[] faces = {BlockFace.NORTH, BlockFace.SOUTH, BlockFace.EAST, BlockFace.WEST, 
                            BlockFace.UP, BlockFace.DOWN}; // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã
        
        for (BlockFace face : faces) {
            Block signBlock = block.getRelative(face);
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ —Ç–∏–ø—ã —Ç–∞–±–ª–∏—á–µ–∫
            if (signBlock.getBlockData() instanceof WallSign || 
                signBlock.getType() == Material.OAK_SIGN ||
                signBlock.getType() == Material.OAK_WALL_SIGN ||
                signBlock.getType().name().contains("SIGN")) {
                
                signBlock.setType(Material.AIR);
                // plugin.getLogger().fine("Removed sign at " + signBlock.getLocation() + " near block at " + location); // –£–ë–ò–†–ê–ï–ú –°–ü–ê–ú
            }
        }
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç CodeBlock –ø–æ –ª–æ–∫–∞—Ü–∏–∏
     */
    public CodeBlock getCodeBlock(Location location) {
        return blockCodeBlocks.get(location);
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –µ—Å—Ç—å –ª–∏ CodeBlock –ø–æ –ª–æ–∫–∞—Ü–∏–∏
     */
    public boolean hasCodeBlock(Location location) {
        return blockCodeBlocks.containsKey(location);
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç –≤—Å–µ CodeBlock'–∏
     */
    public Map<Location, CodeBlock> getAllCodeBlocks() {
        return new HashMap<>(blockCodeBlocks);
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç –≤—Å–µ CodeBlock'–∏ (–¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
     */
    public Map<Location, CodeBlock> getBlockCodeBlocks() {
        return new HashMap<>(blockCodeBlocks);
    }
    
    /**
     * –û—á–∏—â–∞–µ—Ç –≤—Å–µ CodeBlock'–∏ –≤ –º–∏—Ä–µ
     */
    public void clearAllCodeBlocksInWorld(World world) {
        blockCodeBlocks.entrySet().removeIf(entry -> entry.getKey().getWorld().equals(world));
        plugin.getLogger().info("Cleared all code blocks from world: " + world.getName() + " in BlockPlacementHandler.");
    }
    
    /**
     * –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç CodeBlocks —Å AutoConnectionManager
     * –î–æ–ª–∂–Ω–æ –≤—ã–∑—ã–≤–∞—Ç—å—Å—è –ø–æ—Å–ª–µ –ø–æ–ª–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
     */
    public void synchronizeWithAutoConnection() {
        com.megacreative.coding.AutoConnectionManager autoConnection = plugin.getServiceRegistry().getAutoConnectionManager();
        if (autoConnection != null) {
            autoConnection.synchronizeWithPlacementHandler(this);
            plugin.getLogger().info("BlockPlacementHandler synchronized with AutoConnectionManager");
        }
    }
    
    /**
     * Sets the direction of a piston based on bracket type
     */
    private void setPistonDirection(Block pistonBlock, CodeBlock.BracketType bracketType) {
        org.bukkit.block.data.type.Piston pistonData = (org.bukkit.block.data.type.Piston) pistonBlock.getBlockData();
        
        // Set direction based on bracket type for FrameLand-style orientation
        if (bracketType == CodeBlock.BracketType.OPEN) {
            pistonData.setFacing(org.bukkit.block.BlockFace.EAST); // Pointing right for opening bracket {
        } else {
            pistonData.setFacing(org.bukkit.block.BlockFace.WEST); // Pointing left for closing bracket }
        }
        
        pistonBlock.setBlockData(pistonData);
    }
    
    /**
     * Toggles the bracket type and updates the visual representation
     */
    private void toggleBracketType(CodeBlock codeBlock, Block pistonBlock, Player player) {
        CodeBlock.BracketType currentType = codeBlock.getBracketType();
        CodeBlock.BracketType newType = (currentType == CodeBlock.BracketType.OPEN) ? 
            CodeBlock.BracketType.CLOSE : CodeBlock.BracketType.OPEN;
        
        codeBlock.setBracketType(newType);
        setPistonDirection(pistonBlock, newType);
        
        player.sendMessage("¬ßa–°–∫–æ–±–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞: ¬ßf" + newType.getSymbol() + " " + newType.getDisplayName());
        
        // Update the sign to reflect the new bracket type
        updateBracketSign(pistonBlock.getLocation(), newType);
        
        // –í–ê–ñ–ù–û: –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–∏—Ä –ø–æ—Å–ª–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ç–∏–ø–∞ —Å–∫–æ–±–∫–∏
        var creativeWorld = plugin.getWorldManager().findCreativeWorldByBukkit(player.getWorld());
        if (creativeWorld != null) {
            plugin.getWorldManager().saveWorld(creativeWorld);
        }
        
        plugin.getLogger().info("Bracket type toggled to: " + newType + " at " + pistonBlock.getLocation());
    }
    
    /**
     * Updates the sign for a bracket block
     */
    private void updateBracketSign(Location location, CodeBlock.BracketType bracketType) {
        // Remove old sign and create new one with bracket info
        removeSignFromBlock(location);
        
        Block block = location.getBlock();
        BlockFace[] faces = {BlockFace.NORTH, BlockFace.EAST, BlockFace.SOUTH, BlockFace.WEST};
        
        for (BlockFace face : faces) {
            Block signBlock = block.getRelative(face);
            if (signBlock.getType().isAir()) {
                signBlock.setType(Material.OAK_WALL_SIGN, false);
                
                org.bukkit.block.data.type.WallSign wallSignData = (org.bukkit.block.data.type.WallSign) signBlock.getBlockData();
                wallSignData.setFacing(face);
                signBlock.setBlockData(wallSignData);
                
                org.bukkit.block.Sign signState = (org.bukkit.block.Sign) signBlock.getState();
                signState.setLine(0, "¬ß8============");
                signState.setLine(1, "¬ß6" + bracketType.getSymbol() + " –°–∫–æ–±–∫–∞");
                signState.setLine(2, "¬ß7–ü–ö–ú –¥–ª—è —Å–º–µ–Ω—ã");
                signState.setLine(3, "¬ß8============");
                signState.update(true);
                
                return;
            }
        }
    }
    
    /**
     * Handles Arrow NOT interaction for negating conditions
     */
    private void handleArrowNotInteraction(Player player, Block clickedBlock) {
        if (clickedBlock == null) {
            player.sendMessage("¬ßc–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –±–ª–æ–∫!");
            return;
        }
        
        Location location = clickedBlock.getLocation();
        CodeBlock codeBlock = blockCodeBlocks.get(location);
        
        if (codeBlock == null) {
            player.sendMessage("¬ßc–û—à–∏–±–∫–∞: –≠—Ç–æ –Ω–µ –±–ª–æ–∫ –∫–æ–¥–∞!");
            return;
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ –±–ª–æ–∫–æ–º —É—Å–ª–æ–≤–∏—è
        BlockConfigService.BlockConfig config = blockConfigService.getBlockConfig(codeBlock.getAction());
        if (config == null || !"CONDITION".equals(config.getType())) {
            player.sendMessage("¬ßc–û—à–∏–±–∫–∞: –°—Ç—Ä–µ–ª–∫—É –ù–ï –º–æ–∂–Ω–æ –ø—Ä–∏–º–µ–Ω—è—Ç—å —Ç–æ–ª—å–∫–æ –∫ –±–ª–æ–∫–∞–º —É—Å–ª–æ–≤–∏–π!");
            return;
        }
        
        // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä negated
        boolean currentNegated = false;
        if (codeBlock.getParameter("negated") != null) {
            currentNegated = Boolean.parseBoolean(codeBlock.getParameter("negated").toString());
        }
        
        boolean newNegated = !currentNegated;
        codeBlock.setParameter("negated", newNegated);
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–∞–±–ª–∏—á–∫—É, —á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ—Ç—Ä–∏—Ü–∞–Ω–∏—è
        updateConditionSign(location, config.getDisplayName(), newNegated);
        
        if (newNegated) {
            player.sendMessage("¬ßa‚úì –û—Ç—Ä–∏—Ü–∞–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ –∫ —É—Å–ª–æ–≤–∏—é: ¬ßf–ù–ï " + config.getDisplayName());
        } else {
            player.sendMessage("¬ßc‚úó –û—Ç—Ä–∏—Ü–∞–Ω–∏–µ —É–±—Ä–∞–Ω–æ —Å —É—Å–ª–æ–≤–∏—è: ¬ßf" + config.getDisplayName());
        }
        
        plugin.getLogger().info("Arrow NOT applied to condition block at " + location + ", negated: " + newNegated);
    }
    
    /**
     * Updates the sign for a condition block to show negation status
     */
    private void updateConditionSign(Location location, String displayName, boolean negated) {
        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—É—é —Ç–∞–±–ª–∏—á–∫—É –∏ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é
        removeSignFromBlock(location);
        
        Block block = location.getBlock();
        BlockFace[] faces = {BlockFace.NORTH, BlockFace.EAST, BlockFace.SOUTH, BlockFace.WEST};
        
        for (BlockFace face : faces) {
            Block signBlock = block.getRelative(face);
            if (signBlock.getType().isAir()) {
                signBlock.setType(Material.OAK_WALL_SIGN, false);
                
                org.bukkit.block.data.type.WallSign wallSignData = (org.bukkit.block.data.type.WallSign) signBlock.getBlockData();
                wallSignData.setFacing(face);
                signBlock.setBlockData(wallSignData);
                
                org.bukkit.block.Sign signState = (Sign) signBlock.getState();
                signState.setLine(0, "¬ß8============");
                
                if (negated) {
                    signState.setLine(1, "¬ßc–ù–ï " + displayName.substring(0, Math.min(displayName.length(), 12)));
                    signState.setLine(2, "¬ß7(–æ—Ç—Ä–∏—Ü–∞–Ω–∏–µ)");
                } else {
                    String line2 = displayName.length() > 15 ? displayName.substring(0, 15) : displayName;
                    signState.setLine(1, line2);
                    signState.setLine(2, "¬ß7–ö–ª–∏–∫–Ω–∏—Ç–µ –ü–ö–ú");
                }
                signState.setLine(3, "¬ß8============");
                signState.update(true);
                
                return;
            }
        }
    }
    
    /**
     * üéÜ ENHANCED: Finds optimal build direction based on available space
     */
    private BlockFace findOptimalBuildDirection(Location center, int bracketDistance) {
        BlockFace[] directions = {BlockFace.EAST, BlockFace.WEST, BlockFace.NORTH, BlockFace.SOUTH};
        
        for (BlockFace direction : directions) {
            boolean hasSpace = true;
            
            // Check if we have enough space in this direction
            for (int i = 1; i <= bracketDistance + 1; i++) {
                Location checkLoc = center.clone().add(
                    direction.getModX() * i, 
                    0, 
                    direction.getModZ() * i
                );
                
                if (!checkLoc.getBlock().getType().isAir()) {
                    hasSpace = false;
                    break;
                }
            }
            
            if (hasSpace) {
                return direction;
            }
        }
        
        // Default to east if no space found
        return BlockFace.EAST;
    }
    
    /**
     * üéÜ ENHANCED: Adds magical construction effects
     */
    private void addConstructionEffects(Location location, Player player) {
        // Visual effects
        player.spawnParticle(org.bukkit.Particle.VILLAGER_HAPPY, 
            location.clone().add(0.5, 1.0, 0.5), 10, 0.3, 0.3, 0.3, 0.1);
        player.spawnParticle(org.bukkit.Particle.END_ROD, 
            location.clone().add(0.5, 0.5, 0.5), 5, 0.2, 0.2, 0.2, 0.05);
        
        // Audio feedback
        player.playSound(location, org.bukkit.Sound.BLOCK_ENCHANTMENT_TABLE_USE, 0.8f, 1.2f);
        player.playSound(location, org.bukkit.Sound.ENTITY_EXPERIENCE_ORB_PICKUP, 1.0f, 1.5f);
        
        // Delayed sparkle effect
        plugin.getServer().getScheduler().runTaskLater(plugin, () -> {
            player.spawnParticle(org.bukkit.Particle.FIREWORKS_SPARK, 
                location.clone().add(0.5, 1.5, 0.5), 8, 0.4, 0.4, 0.4, 0.1);
        }, 10L);
    }
    
    /**
     * üéÜ ENHANCED: Handles smart sign clicks to open configuration GUIs
     * This restores the FrameLand "magic" of clicking signs to configure blocks
     */
    private boolean handleSmartSignClick(Block signBlock, Player player) {
        if (!(signBlock.getState() instanceof Sign)) {
            return false;
        }
        
        Sign sign = (Sign) signBlock.getState();
        
        // Check if this is a smart sign (has our special markers)
        String[] lines = sign.getLines();
        if (lines.length < 3 || !lines[2].contains("–ö–ª–∏–∫ –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏")) {
            return false;
        }
        
        // Find the associated code block (sign should be adjacent to it)
        BlockFace[] adjacentFaces = {BlockFace.NORTH, BlockFace.SOUTH, BlockFace.EAST, BlockFace.WEST};
        
        for (BlockFace face : adjacentFaces) {
            Block adjacentBlock = signBlock.getRelative(face);
            Location blockLoc = adjacentBlock.getLocation();
            
            if (blockCodeBlocks.containsKey(blockLoc)) {
                CodeBlock codeBlock = blockCodeBlocks.get(blockLoc);
                
                // Open appropriate GUI based on block state
                if (codeBlock.getAction() == null || "NOT_SET".equals(codeBlock.getAction())) {
                    // No action set - open action selection GUI
                    openActionSelectionGUI(player, blockLoc, adjacentBlock.getType());
                } else {
                    // Action already set - open parameter configuration GUI
                    BlockConfigService.BlockConfig config = blockConfigService.getBlockConfig(codeBlock.getAction());
                    if (config != null) {
                        openParameterConfigGUI(player, blockLoc, codeBlock, config);
                    } else {
                        player.sendMessage("¬ßc–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è –¥–µ–π—Å—Ç–≤–∏—è " + codeBlock.getAction());
                    }
                }
                
                // Add magical click effects
                player.spawnParticle(org.bukkit.Particle.VILLAGER_HAPPY, 
                    signBlock.getLocation().add(0.5, 0.5, 0.5), 3, 0.1, 0.1, 0.1, 0.1);
                player.playSound(signBlock.getLocation(), org.bukkit.Sound.UI_BUTTON_CLICK, 0.8f, 1.2f);
                
                return true; // Successfully handled
            }
        }
        
        return false; // Not a smart sign or no associated block found
    }
    
    /**
     * üéÜ ENHANCED: Creates smart sign that opens configuration GUI on right-click
     * This restores the FrameLand "magic" of clicking signs to configure blocks
     */
    private void setSmartSignOnBlock(Location location, String displayName, String blockId) {
        removeSignFromBlock(location); // Remove old signs first

        Block block = location.getBlock();
        // Define priority sides for installation
        BlockFace[] faces = {BlockFace.NORTH, BlockFace.EAST, BlockFace.SOUTH, BlockFace.WEST};
        
        for (BlockFace face : faces) {
            Block signBlock = block.getRelative(face);
            if (signBlock.getType().isAir()) {
                signBlock.setType(Material.OAK_WALL_SIGN, false); // false - don't trigger physics
                
                WallSign wallSignData = (WallSign) signBlock.getBlockData();
                wallSignData.setFacing(face); // Sign faces the block
                signBlock.setBlockData(wallSignData);
                
                Sign signState = (Sign) signBlock.getState();
                signState.setLine(0, "¬ß6‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ");
                // Trim text if too long
                String line1 = displayName.length() > 15 ? displayName.substring(0, 15) : displayName;
                signState.setLine(1, "¬ße" + line1);
                signState.setLine(2, "¬ßa‚ûú –ö–ª–∏–∫ –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏");
                signState.setLine(3, "¬ß6‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ");
                signState.update(true);
                
                return; // IMPORTANT: Exit after placing FIRST sign
            }
        }
    }
    
    /**
     * üéÜ ENHANCED: Recreates a CodeBlock from an existing physical block and sign
     * This is used during world loading to "hydrate" code blocks
     */
    public void recreateCodeBlockFromExisting(Block block, Sign sign) {
        Location location = block.getLocation();
        
        // Check if we already have this block registered
        if (blockCodeBlocks.containsKey(location)) {
            return; // Already exists
        }
        
        Material material = block.getType();
        String action = determineActionFromBlockAndSign(block, sign);
        
        // Create the CodeBlock
        CodeBlock codeBlock = new CodeBlock(material, action);
        
        // Special handling for bracket blocks
        if (material == Material.PISTON || material == Material.STICKY_PISTON) {
            // Determine bracket type from sign text
            String[] lines = sign.getLines();
            if (lines.length > 1) {
                String line2 = lines[1];
                if (line2.contains("{")) {
                    codeBlock.setBracketType(CodeBlock.BracketType.OPEN);
                } else if (line2.contains("}")) {
                    codeBlock.setBracketType(CodeBlock.BracketType.CLOSE);
                }
            }
        }
        
        // üîß FIX: Restore parameters from container above the block
        restoreParametersFromContainer(block, codeBlock);
        
        // Add to our tracking
        blockCodeBlocks.put(location, codeBlock);
        
        plugin.getLogger().fine("Recreated CodeBlock at " + location + " with action: " + action);
    }
    
    /**
     * üîß FIX: Restores parameters from container (chest) above the code block
     * This is used during world loading to "hydrate" code block parameters
     */
    private void restoreParametersFromContainer(Block block, CodeBlock codeBlock) {
        try {
            // Look for container above the block
            Location containerLocation = block.getLocation().clone().add(0, 1, 0);
            Block containerBlock = containerLocation.getBlock();
            
            // Check if it's a container block
            if (containerBlock.getState() instanceof org.bukkit.block.Container container) {
                org.bukkit.inventory.Inventory inventory = container.getInventory();
                
                // Convert ItemStacks to DataValue parameters
                convertItemStacksToParameters(inventory, codeBlock);
                
                plugin.getLogger().fine("Restored parameters for CodeBlock at " + block.getLocation() + " from container");
            }
        } catch (Exception e) {
            plugin.getLogger().warning("Failed to restore parameters from container for block at " + block.getLocation() + ": " + e.getMessage());
        }
    }
    
    /**
     * Converts ItemStacks from GUI inventory to DataValue parameters in CodeBlock
     * This is a copy of the method from BlockConfigManager with necessary modifications
     */
    private void convertItemStacksToParameters(org.bukkit.inventory.Inventory inventory, CodeBlock codeBlock) {
        Map<String, com.megacreative.coding.values.DataValue> newParameters = new HashMap<>();
        int processedItems = 0;
        
        // Process each slot in the inventory
        for (int slot = 0; slot < inventory.getSize(); slot++) {
            org.bukkit.inventory.ItemStack item = inventory.getItem(slot);
            if (item == null || item.getType().isAir()) continue;
            
            // Skip placeholder items
            if (isPlaceholderItem(item)) continue;
            
            // Try to determine parameter name for this slot
            String paramName = getParameterNameForSlot(codeBlock.getAction(), slot);
            if (paramName == null) {
                // Fallback: use generic slot-based parameter name
                paramName = "slot_" + slot;
            }
            
            // Convert ItemStack to DataValue
            com.megacreative.coding.values.DataValue paramValue = convertItemStackToDataValue(item);
            if (paramValue != null) {
                newParameters.put(paramName, paramValue);
                processedItems++;
            }
        }
        
        // Update CodeBlock parameters
        for (Map.Entry<String, com.megacreative.coding.values.DataValue> entry : newParameters.entrySet()) {
            codeBlock.setParameter(entry.getKey(), entry.getValue());
        }
        
        if (processedItems > 0) {
            plugin.getLogger().info("Converted " + processedItems + " ItemStacks to DataValue parameters for block " + codeBlock.getAction());
        }
    }
    
    /**
     * Converts an ItemStack to a DataValue
     * This is a copy of the method from BlockConfigManager with necessary modifications
     */
    private com.megacreative.coding.values.DataValue convertItemStackToDataValue(org.bukkit.inventory.ItemStack item) {
        if (item == null || item.getType().isAir()) {
            return new com.megacreative.coding.values.types.AnyValue(null);
        }
        
        org.bukkit.inventory.meta.ItemMeta meta = item.getItemMeta();
        String displayName = meta != null && meta.hasDisplayName() ? meta.getDisplayName() : "";
        
        // Clean display name from color codes for processing
        String cleanName = displayName.replaceAll("¬ß[0-9a-fk-or]", "");
        
        // 1. Try to extract value from existing parameter items (our converted items)
        if (meta != null && meta.hasLore()) {
            List<String> lore = meta.getLore();
            for (String line : lore) {
                if (line.startsWith("¬ß8Parameter: ")) {
                    // This is a parameter item we created - extract the value
                    return extractValueFromParameterItem(item, lore);
                }
            }
        }
        
        // 2. Try to detect type from material
        switch (item.getType()) {
            case PAPER:
                // Extract text from display name or use item name
                if (!cleanName.isEmpty()) {
                    return new com.megacreative.coding.values.types.TextValue(cleanName);
                } else {
                    return new com.megacreative.coding.values.types.TextValue("–¢–µ–∫—Å—Ç");
                }
            
            case GOLD_NUGGET:
            case GOLD_INGOT:
                // Try to parse number from name or use amount
                if (!cleanName.isEmpty()) {
                    try {
                        String numberStr = cleanName.replaceAll("[^0-9.-]", "");
                        if (!numberStr.isEmpty()) {
                            return new com.megacreative.coding.values.types.NumberValue(Double.parseDouble(numberStr));
                        }
                    } catch (NumberFormatException ignored) {}
                }
                return new com.megacreative.coding.values.types.NumberValue(item.getAmount());
            
            case LIME_DYE:
                return new com.megacreative.coding.values.types.BooleanValue(true);
            case RED_DYE:
                return new com.megacreative.coding.values.types.BooleanValue(false);
            
            case CHEST:
            case BARREL:
                // Consider these as lists or containers
                return new com.megacreative.coding.values.types.ListValue(new java.util.ArrayList<>()); // üîß FIX: Pass empty list to constructor
            
            default:
                // For other items, create text value from name or material
                if (!cleanName.isEmpty()) {
                    return new com.megacreative.coding.values.types.TextValue(cleanName);
                } else {
                    // Use material name as text value
                    return new com.megacreative.coding.values.types.TextValue(item.getType().name().toLowerCase().replace("_", " "));
                }
        }
    }
    
    /**
     * Extracts value from a parameter item we created
     * This is a copy of the method from BlockConfigManager with necessary modifications
     */
    private com.megacreative.coding.values.DataValue extractValueFromParameterItem(org.bukkit.inventory.ItemStack item, List<String> lore) {
        // Look for "Value: " line in lore
        for (String line : lore) {
            String cleanLine = line.replaceAll("¬ß[0-9a-fk-or]", "");
            if (cleanLine.startsWith("Value: ")) {
                String valueStr = cleanLine.substring(7); // Remove "Value: "
                
                // Check type from the previous line
                int index = lore.indexOf(line);
                if (index > 0) {
                    String typeLine = lore.get(index - 1).replaceAll("¬ß[0-9a-fk-or]", "");
                    
                    if (typeLine.contains("Number")) {
                        try {
                            return new com.megacreative.coding.values.types.NumberValue(Double.parseDouble(valueStr));
                        } catch (NumberFormatException e) {
                            return new com.megacreative.coding.values.types.TextValue(valueStr);
                        }
                    } else if (typeLine.contains("Boolean")) {
                        return new com.megacreative.coding.values.types.BooleanValue("True".equalsIgnoreCase(valueStr));
                    } else if (typeLine.contains("List")) {
                        return new com.megacreative.coding.values.types.ListValue(new java.util.ArrayList<>()); // üîß FIX: Pass empty list to constructor
                    }
                }
                
                // Default to text
                return new com.megacreative.coding.values.types.TextValue(valueStr);
            }
        }
        
        // Fallback
        return new com.megacreative.coding.values.types.TextValue(item.getType().name().toLowerCase());
    }
    
    /**
     * Gets parameter name for a specific slot based on action type
     * This is a copy of the method from BlockConfigManager with necessary modifications
     */
    private String getParameterNameForSlot(String action, int slot) {
        // Action-specific parameter mapping based on coding_blocks.yml
        switch (action) {
            case "sendMessage":
                return slot == 0 ? "message" : "param_" + slot;
            case "teleport":
                return slot == 0 ? "coords" : "param_" + slot;
            case "giveItem":
                return switch (slot) {
                    case 0 -> "item";
                    case 1 -> "amount";
                    default -> "param_" + slot;
                };
            case "playSound":
                return switch (slot) {
                    case 0 -> "sound";
                    case 1 -> "volume";
                    case 2 -> "pitch";
                    default -> "param_" + slot;
                };
            case "effect":
                return switch (slot) {
                    case 0 -> "effect";
                    case 1 -> "duration";
                    case 2 -> "amplifier";
                    default -> "param_" + slot;
                };
            case "setVar":
            case "addVar":
            case "subVar":
            case "mulVar":
            case "divVar":
                return switch (slot) {
                    case 0 -> "var";
                    case 1 -> "value";
                    default -> "param_" + slot;
                };
            case "spawnMob":
                return switch (slot) {
                    case 0 -> "mob";
                    case 1 -> "amount";
                    default -> "param_" + slot;
                };
            case "wait":
                return slot == 0 ? "ticks" : "param_" + slot;
            case "randomNumber":
                return switch (slot) {
                    case 0 -> "min";
                    case 1 -> "max";
                    case 2 -> "var";
                    default -> "param_" + slot;
                };
            case "setTime":
                return slot == 0 ? "time" : "param_" + slot;
            case "setWeather":
                return slot == 0 ? "weather" : "param_" + slot;
            case "command":
                return slot == 0 ? "command" : "param_" + slot;
            case "broadcast":
                return slot == 0 ? "message" : "param_" + slot;
            case "healPlayer":
                return slot == 0 ? "amount" : "param_" + slot;
            case "explosion":
                return switch (slot) {
                    case 0 -> "power";
                    case 1 -> "breakBlocks";
                    default -> "param_" + slot;
                };
            case "setBlock":
                return switch (slot) {
                    case 0 -> "material";
                    case 1 -> "coords";
                    default -> "param_" + slot;
                };
            // Variable conditions (unified handling)
            case "compareVariable":
                return switch (slot) {
                    case 0 -> "var1";
                    case 1 -> "operator";
                    case 2 -> "var2";
                    default -> "param_" + slot;
                };
            case "ifVarEquals":
            case "ifVarGreater":
            case "ifVarLess":
                return switch (slot) {
                    case 0 -> "variable"; // Legacy parameter name for backward compatibility
                    case 1 -> "value";
                    default -> "param_" + slot;
                };
            case "hasItem":
                return slot == 0 ? "item" : "param_" + slot;
            case "isNearBlock":
                return switch (slot) {
                    case 0 -> "block";
                    case 1 -> "radius";
                    default -> "param_" + slot;
                };
            case "mobNear":
                return switch (slot) {
                    case 0 -> "mob";
                    case 1 -> "radius";
                    default -> "param_" + slot;
                };
            
            // Generic fallback
            default:
                return switch (slot) {
                    case 0 -> "message";
                    case 1 -> "amount";
                    case 2 -> "target";
                    case 3 -> "item";
                    case 4 -> "location";
                    default -> "param_" + slot;
                };
        }
    }
    
    /**
     * Checks if an ItemStack is a placeholder item
     * This is a copy of the method from BlockConfigManager with necessary modifications
     */
    private boolean isPlaceholderItem(org.bukkit.inventory.ItemStack item) {
        if (item == null || !item.hasItemMeta()) return false;
        
        org.bukkit.inventory.meta.ItemMeta meta = item.getItemMeta();
        if (meta.hasLore()) {
            List<String> lore = meta.getLore();
            for (String line : lore) {
                if (line.contains("placeholder") || line.contains("Placeholder")) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * üéÜ ENHANCED: Determines the action for a block based on its material and sign
     */
    private String determineActionFromBlockAndSign(Block block, Sign sign) {
        Material material = block.getType();
        
        // Get the block configuration
        BlockConfigService.BlockConfig config = blockConfigService.getFirstBlockConfig(material);
        if (config != null) {
            // Check if there's a default action
            if (config.getDefaultAction() != null) {
                return config.getDefaultAction();
            }
            // Fallback to block ID
            return config.getId();
        }
        
        // Fallback for unknown blocks
        return "UNKNOWN";
    }
    
    /**
     * Gets the first block configuration for a material
     * @param material The material to look up
     * @return The block configuration or null if not found
     */
    public BlockConfigService.BlockConfig getBlockConfigForMaterial(Material material) {
        return blockConfigService.getFirstBlockConfig(material);
    }
}